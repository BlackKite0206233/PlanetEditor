Q : 什麼是Class？
A : 他像是一個範本，透過方法、屬性來規定Object生成後會長什麼樣子。Class有3個很重要的特性，封裝、繼承、多型。

Q : 什麼是Constructor？
A : 要將Class實體化成Object時會用到的function。

Q : 什麼是Destructor？
A : 要將這個Object刪除時會用到的function，目的是記憶體回收。

Q : 什麼是Interface？
A : Interface有點像是Class，但是他不能實體化，他的目的是規範引用他的Class須要實做哪些function。
    舉個例子，"圓形"、"方形"、"三角形"都可以繼承"形狀"這個Class，我們可以把他們共同的特性寫在"形狀"這個Class裡，這樣繼承的時候"圓形"、"方形"、"三角形"都能夠擁有這些特性。
    可是如果有一個特性是只有"方形"跟"三角形"才有的，這個特性就不能寫在"形狀"這個Class裡面，而是使用Interface規範這些特性，讓"方形"跟"三角形"引用。
    這樣就不用在"方形"跟"三角形"內寫同樣的程式碼，讓程式在維護上更加方便。

Q : 什麼是Polymorphism？ 我在哪使用了Polymorphism？
A : 1. 子類別可以繼承父類別的function，也可以透過override或virtual，針對不同的子類別改寫function。
       宣告時可以將變數宣告成父類別，實體化時再跟據程式決定要實體化成哪個子類別，這樣就可以相同的程式碼在變數為不同的類別時，有不同的行為。
       舉例來說，"貓"跟"狗"都是繼承"動物"這個Class，都有"叫"這個方法，可是兩種動物的叫聲不一樣。
       所以我們可以在"動物"這個Class定義"叫"這個方法，然後在"貓"跟"狗"這兩個Class重寫這個方法。
       當我們宣告變數時可以宣告"動物"，實體化時再決定這個動物要是狗還是貓。
       當呼叫"叫"的這個function時，就會跟據實體化的不同而出現不同的叫聲。
    2. 在CreatureType跟他的子類別Lion、Plant有用到(move、absorb、alive、deadOrAlive、birth)，
       還有在Object跟他的子類別Planet、Creature(update)。
    
Q : 什麼是template？
A : 樣板，類似C#的泛型，能讓Class或function傳入不同的資料型別，這樣就不用根據不同資料型別寫不同的程式碼。

Q : Planet::Planet(const Planet & src)將會產生什麼問題？
A : src._object_ptrs是shared_ptr，在跑range-based for的時後會出問題

Q : std::shared_ptr是什麼？
A : C++的smart point的一種，他允許很多個shared_ptr指到同一塊記憶體，只要那塊記憶體還有被任何一個shared_ptr指到，他就不會被釋放，
    等到沒有任何shared_ptr指到那塊記憶體，快記憶體才會被釋放。這樣可以確保程式比較不會出錯。

Q : 如果忘記釋放記憶體會發生什麼事？ C#會發生相同的事嗎？
A : 1. 忘記釋放記憶體，那個變數的生命周期又結束的話，會造成memory leak，就是一塊記憶體佔在那邊，但是完全沒被使用到。
    2. C#有自動回收的功能，所以不會有這個問題，但是如果都不自己釋放，全部交給系統的話，會造成程式執行效率變低。